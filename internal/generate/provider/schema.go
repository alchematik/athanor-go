package provider

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/format"
	"sort"
	"text/template"

	providerpb "github.com/alchematik/athanor-go/internal/gen/go/proto/provider/v1"
	util "github.com/alchematik/athanor-go/internal/generate/template"
)

//go:embed resource.tmpl
var resourceTmpl string

//go:embed struct_type.tmpl
var structTypeTmpl string

//go:embed provider.tmpl
var providerTmpl string

func GenerateProviderCommonSrc(schema *providerpb.Schema) ([]byte, error) {
	resources := schema.GetResources()
	sort.Slice(resources, func(i, j int) bool {
		return resources[i].GetType() < resources[j].GetType()
	})

	resourceNames := make([]string, len(resources))
	for i, r := range resources {
		resourceNames[i] = r.GetType()
	}

	tmpl, err := template.New("provider").
		Funcs(template.FuncMap{
			"toPascalCase": util.PascalCase,
		}).
		Parse(providerTmpl)
	if err != nil {
		return nil, err
	}

	providerData := map[string]any{
		"PackageName": "provider",
		"Types":       resourceNames,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, providerData); err != nil {
		return nil, err
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return src, nil
}

func GenerateResourceSrc(resource *providerpb.ResourceSchema) ([]byte, error) {
	name := resource.GetType()

	tmpl, err := template.New("resource").
		Funcs(template.FuncMap{
			"toPascalCase": util.PascalCase,
		}).
		Parse(resourceTmpl)
	if err != nil {
		return nil, err
	}

	data := map[string]any{
		"PackageName": "provider",
		"Type":        util.PascalCase(name),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	typesMap := map[string]*providerpb.FieldSchema{}

	id := resource.GetIdentifier()
	id.Name = resource.GetType() + "_identifier"
	typesMap[id.Name] = id
	if err := addTypes(typesMap, id); err != nil {
		return nil, err
	}

	config := resource.GetConfig()
	config.Name = resource.GetType() + "_config"
	typesMap[config.Name] = config
	if err := addTypes(typesMap, config); err != nil {
		return nil, err
	}

	attrs := resource.GetAttrs()
	attrs.Name = resource.GetType() + "_attrs"
	typesMap[attrs.Name] = attrs
	if err := addTypes(typesMap, attrs); err != nil {
		return nil, err
	}

	var names []string
	for k := range typesMap {
		names = append(names, k)
	}

	sort.Strings(names)

	resourceTypes := make([]*providerpb.FieldSchema, len(names))

	for i, name := range names {
		resourceTypes[i] = typesMap[name]
	}

	out := buf.Bytes()
	for _, t := range resourceTypes {
		switch t.GetType() {
		case providerpb.FieldType_STRUCT:
			o, err := generateStructType(name, t)
			if err != nil {
				return nil, err
			}

			out = append(out, o...)
		default:
			return nil, fmt.Errorf("unsupported type: %s", t.GetType())
		}
	}

	return format.Source(out)
}

func addTypes(types map[string]*providerpb.FieldSchema, field *providerpb.FieldSchema) error {
	for _, f := range field.GetFields() {
		if f.GetType() == providerpb.FieldType_STRUCT {
			// Skip nested identifiers because those should get generated by the resource which the identifier belongs to.
			if f.GetIsIdentifier() {
				continue
			}

			if _, ok := types[f.GetName()]; ok {
				return fmt.Errorf("duplicate type definition: %s\n", f.GetName())
			}

			types[f.GetName()] = f
			if err := addTypes(types, f); err != nil {
				return err
			}
		}
	}

	return nil
}

func generateStructType(name string, t *providerpb.FieldSchema) ([]byte, error) {
	tmpl, err := template.New("struct_type").
		Funcs(template.FuncMap{
			"toPascalCase": util.PascalCase,
			"parseFieldFunc": func(f *providerpb.FieldSchema) (string, error) {
				if f.IsIdentifier {
					return "ParseIdentifier", nil
				}
				switch f.GetType() {
				case providerpb.FieldType_STRING:
					return "sdk.ParseStringValue", nil
				case providerpb.FieldType_STRUCT:
					return fmt.Sprintf("Parse%s", util.PascalCase(f.Name)), nil
				default:
					return "", fmt.Errorf("unsupported type %s", f.GetType())
				}
			},
			"toType": func(f *providerpb.FieldSchema) (string, error) {
				if f.GetIsIdentifier() {
					return "sdk.ResourceIdentifier", nil
				}

				switch f.GetType() {
				case providerpb.FieldType_STRING:
					return "string", nil
				case providerpb.FieldType_STRUCT:
					return util.PascalCase(f.GetName()), nil
				default:
					return "", fmt.Errorf("unrecognized type: %s", f.GetType())
				}
			},
		}).
		Parse(structTypeTmpl)
	if err != nil {
		return nil, err
	}

	data := map[string]any{
		"ResourceName": name,
		"Type":         t,
	}

	var buffer bytes.Buffer
	if err := tmpl.Execute(&buffer, data); err != nil {
		return nil, err
	}

	return buffer.Bytes(), nil
}
